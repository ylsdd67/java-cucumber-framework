# 架构设计文档

> 版本：1.0.0 | 最后更新：2026-02-28

---

## 1. 项目概述

本项目是一个基于 **Java 21 + Maven + Cucumber** 的可扩展 BDD（行为驱动开发）测试框架，专为 API 和协议测试而设计。

### 1.1 设计目标

| 目标           | 说明                                                                    |
| -------------- | ----------------------------------------------------------------------- |
| **协议无关性** | 核心架构不绑定任何具体协议，通过插件机制支持 REST、SOAP、MQTT、Kafka 等 |
| **可扩展性**   | 新增协议/中间件只需实现接口 + 注册，零改动核心代码                      |
| **BDD 驱动**   | 使用 Gherkin 自然语言编写用例，业务人员可读可写                         |
| **环境隔离**   | 通过 YAML 配置文件 + 环境 Profile 实现多环境切换                        |
| **场景隔离**   | 每个测试场景拥有独立的上下文，互不干扰                                  |
| **开箱即用**   | 内置丰富的 REST API 测试步骤定义，可直接使用                            |

### 1.2 技术选型

| 技术            | 版本            | 用途                                              |
| --------------- | --------------- | ------------------------------------------------- |
| Java (Temurin)  | 21 LTS          | 主语言，使用 Switch 表达式、Text Block 等现代特性 |
| Maven           | 3.9.9           | 构建管理（通过 Maven Wrapper，无需全局安装）      |
| Cucumber        | 7.20.1          | BDD 测试框架，Gherkin 语法                        |
| JUnit 5         | 5.11.4          | 测试运行平台                                      |
| REST Assured    | 5.5.0           | REST/HTTP 协议客户端                              |
| Jackson         | 2.18.2          | JSON/YAML 序列化                                  |
| JsonPath        | 2.9.0           | JSON 路径查询与断言                               |
| AssertJ         | 3.27.3          | 流式断言库                                        |
| SLF4J + Logback | 2.0.16 / 1.5.15 | 日志框架                                          |
| PicoContainer   | —               | Cucumber 依赖注入（场景级别）                     |
| Lombok          | 1.18.36         | 减少样板代码（可选）                              |

---

## 2. 架构总览

### 2.1 分层架构图

```
┌──────────────────────────────────────────────────────────────┐
│                    Gherkin Feature 文件                       │
│               （用自然语言描述测试场景）                        │
├──────────────────────────────────────────────────────────────┤
│                  Step Definitions 步骤定义                    │
│         REST 步骤 │ SOAP 步骤 │ MQTT 步骤 │ Kafka 步骤        │
│         (已实现)   │ (待扩展)  │ (待扩展)  │ (待扩展)          │
├──────────────────────────────────────────────────────────────┤
│                    TestContext 测试上下文                      │
│  ┌─────────────┬──────────────┬────────────────────────────┐ │
│  │ 当前请求     │  最近响应    │  场景数据存储 (K-V)         │  │
│  └─────────────┴──────────────┴────────────────────────────┘ │
├──────────────────────────────────────────────────────────────┤
│               ProtocolClientFactory 协议客户端工厂             │
│               （SPI 自动发现 + 手动注册）                      │
├────────────┬──────────────┬──────────────┬───────────────────┤
│ RestClient │  SoapClient  │ MqttClient   │  KafkaClient      │
│ (已实现)    │  (待扩展)    │ (待扩展)      │  (待扩展)         │
├────────────┴──────────────┴──────────────┴───────────────────┤
│           ProtocolClient 接口（核心契约）                      │
│     ProtocolRequest / ProtocolResponse（通用数据模型）         │
├──────────────────────────────────────────────────────────────┤
│                ConfigManager 配置管理器                        │
│    YAML 基础配置 → 环境覆盖 → 环境变量 → 系统属性              │
└──────────────────────────────────────────────────────────────┘
```

### 2.2 核心设计原则

| 原则               | 实现方式                                               |
| ------------------ | ------------------------------------------------------ |
| **开闭原则 (OCP)** | 通过 `ProtocolClient` 接口扩展新协议，无需修改已有代码 |
| **依赖倒置 (DIP)** | 步骤定义依赖抽象接口，不直接依赖具体协议实现           |
| **单一职责 (SRP)** | 每个类只负责一件事：配置管理、协议通信、测试上下文等   |
| **工厂模式**       | `ProtocolClientFactory` 统一创建和管理协议客户端       |
| **SPI 插件机制**   | Java `ServiceLoader` 实现协议客户端的自动发现          |

---

## 3. 核心组件设计

### 3.1 ProtocolClient 接口

这是框架的**核心契约**，所有协议客户端必须实现此接口：

```java
public interface ProtocolClient {
    void init(ConfigManager config);           // 初始化（读取配置）
    ProtocolResponse execute(ProtocolRequest request); // 执行请求
    String getProtocolName();                  // 协议名称标识
    default void close() {}                    // 清理资源
}
```

**设计要点：**

- `init()` 方法在客户端创建后由工厂自动调用，传入全局配置
- `execute()` 接收通用请求，返回通用响应，协议细节由实现类内部处理
- `close()` 使用 `default` 方法，非必须实现

### 3.2 ProtocolRequest / ProtocolResponse

通用的请求和响应模型，跨协议使用：

```
ProtocolRequest                     ProtocolResponse
├── endpoint (端点/Topic/队列)       ├── statusCode (状态码)
├── method (方法/动作)               ├── statusLine (状态行)
├── headers (头部/元数据)            ├── headers (响应头)
├── queryParams (查询参数)           ├── body (响应体)
├── pathParams (路径参数)            ├── responseTimeMs (响应时间)
├── body (请求体)                    ├── contentType (内容类型)
├── contentType (内容类型)           └── extras (协议扩展数据)
├── authToken (认证令牌)
├── basicAuth (基础认证)
└── extras (协议扩展数据)
```

**关键设计 — `extras` 字段：**
`extras` 是一个 `Map<String, Object>` 类型的扩展字段，用于承载特定协议的专有数据。例如：

- MQTT 场景：`extras.put("qos", 1)` 设置 QoS 级别
- Kafka 场景：`extras.put("partition", 0)` 指定分区
- REST 场景：`extras.put("rawResponse", response)` 保存原始响应对象

### 3.3 ProtocolClientFactory

客户端工厂，负责协议客户端的**创建、缓存和生命周期管理**：

```
                    ┌──────────────────────┐
                    │ ProtocolClientFactory│
                    ├──────────────────────┤
   SPI 自动发现 ──→ │ registry (注册表)     │ ←── 手动注册
                    │ instances (实例缓存)  │
                    ├──────────────────────┤
                    │ getClient("REST")    │ → 懒加载 + 缓存
                    │ getClient("SOAP")    │ → 懒加载 + 缓存
                    │ closeAll()           │ → 统一清理
                    └──────────────────────┘
```

**两种注册方式：**

1. **SPI 自动发现**：在 `META-INF/services/com.framework.core.client.ProtocolClient` 中注册
2. **手动注册**：`factory.register("MQTT", MqttClient.class)`

### 3.4 TestContext 测试上下文

每个 Cucumber 场景通过 **PicoContainer 依赖注入** 获取独立的 `TestContext` 实例：

```
Scenario A                          Scenario B
┌──────────────────┐                ┌──────────────────┐
│ TestContext       │                │ TestContext       │
│ ├── config       │                │ ├── config       │
│ ├── clientFactory │                │ ├── clientFactory│
│ ├── request(A)   │                │ ├── request(B)   │
│ ├── response(A)  │                │ ├── response(B)  │
│ └── data{...}    │                │ └── data{...}    │
└──────────────────┘                └──────────────────┘
         互相隔离，互不影响
```

### 3.5 ConfigManager 配置管理器

多层级配置加载机制，优先级从高到低：

```
优先级1 (最高)：系统属性        -Drest.base-url=http://...
     ↓
优先级2：环境变量              REST_BASE_URL=http://...
     ↓
优先级3：环境专属 YAML         application-dev.yml
     ↓
优先级4 (最低)：基础 YAML      application.yml
```

**YAML 扁平化处理：**

```yaml
# YAML 源文件
rest:
  base-url: http://localhost:8080
  timeout-ms: 30000

# 内部存储（扁平化 key）
rest.base-url → http://localhost:8080
rest.timeout-ms → 30000
```

---

## 4. 目录结构设计

```
java-cucumber-framework/
├── pom.xml                              # Maven 项目配置
├── mvnw / mvnw.cmd                      # Maven Wrapper（免安装 Maven）
├── .mvn/wrapper/                        # Maven Wrapper 配置
├── .gitignore                           # Git 忽略规则
├── README.md                            # 项目说明（英文）
├── docs/                                # 项目文档（中文）
│
├── src/main/java/com/framework/
│   ├── core/                            # ===== 核心层 =====
│   │   ├── client/
│   │   │   ├── ProtocolClient.java      # 协议客户端接口
│   │   │   ├── ProtocolClientFactory.java # 客户端工厂
│   │   │   ├── ProtocolRequest.java     # 通用请求模型
│   │   │   └── ProtocolResponse.java    # 通用响应模型
│   │   ├── config/
│   │   │   └── ConfigManager.java       # 配置管理器
│   │   └── context/
│   │       └── TestContext.java          # 测试上下文
│   │
│   └── protocols/                       # ===== 协议实现层 =====
│       └── rest/
│           └── RestClient.java          # REST 协议客户端（REST Assured）
│           # 未来扩展：
│           # soap/SoapClient.java
│           # mqtt/MqttClient.java
│           # kafka/KafkaClient.java
│
├── src/main/resources/
│   └── META-INF/services/
│       └── com.framework.core.client.ProtocolClient  # SPI 注册文件
│
└── src/test/
    ├── java/com/framework/
    │   ├── runners/
    │   │   └── CucumberRunner.java      # Cucumber 运行器
    │   ├── hooks/
    │   │   └── Hooks.java               # Before/After 钩子
    │   └── stepdefs/
    │       └── rest/
    │           └── RestStepDefs.java     # REST 步骤定义
    │           # 未来扩展：
    │           # soap/SoapStepDefs.java
    │           # mqtt/MqttStepDefs.java
    │
    └── resources/
        ├── features/                    # Gherkin 测试用例
        │   └── rest/
        │       └── sample_api.feature
        ├── config/                      # 环境配置
        │   ├── application.yml          # 基础配置
        │   ├── application-dev.yml      # 开发环境
        │   └── application-staging.yml  # 预发布环境
        ├── junit-platform.properties    # Cucumber 引擎配置
        ├── cucumber.properties          # Cucumber 属性
        └── logback-test.xml             # 日志配置
```

---

## 5. 数据流设计

### 5.1 测试执行流程

```
                        ┌─────────────────┐
                        │  Maven Surefire │
                        │  触发测试执行    │
                        └────────┬────────┘
                                 ↓
                     ┌──────────────────────┐
                     │  CucumberRunner      │
                     │  (JUnit 5 Suite)     │
                     └────────┬─────────────┘
                              ↓
                 ┌────────────────────────────┐
                 │  Cucumber Engine           │
                 │  扫描 features/ 目录       │
                 │  匹配 @tag 过滤器          │
                 └────────┬───────────────────┘
                          ↓
            ┌──────────────────────────────────┐
            │  每个 Scenario 执行：             │
            │  1. PicoContainer 创建 TestContext│
            │  2. @Before 钩子执行              │
            │  3. Given/When/Then 步骤执行      │
            │  4. @After 钩子执行（含清理）     │
            └──────────────────────────────────┘
```

### 5.2 单个 REST 请求的完整生命周期

```
Feature 文件                Step Definitions             TestContext              RestClient
    │                            │                           │                      │
    │  When I send a GET         │                           │                      │
    │  request to "/users/1"     │                           │                      │
    │ ─────────────────────────→ │                           │                      │
    │                            │  getCurrentRequest()      │                      │
    │                            │ ─────────────────────────→│                      │
    │                            │  set method & endpoint    │                      │
    │                            │ ─────────────────────────→│                      │
    │                            │  executeRest()            │                      │
    │                            │ ─────────────────────────→│                      │
    │                            │                           │  execute(request)    │
    │                            │                           │ ───────────────────→ │
    │                            │                           │                      │ → HTTP GET
    │                            │                           │                      │ ← HTTP 200
    │                            │                           │  ProtocolResponse    │
    │                            │                           │ ←─────────────────── │
    │                            │                           │  setLastResponse()   │
    │                            │  response stored          │                      │
    │                            │ ←─────────────────────────│                      │
    │                            │                           │                      │
    │  Then status code          │                           │                      │
    │  should be 200             │                           │                      │
    │ ─────────────────────────→ │  getLastResponse()        │                      │
    │                            │ ─────────────────────────→│                      │
    │                            │  assert statusCode == 200 │                      │
    │                            │ ✓ PASS                    │                      │
```

---

## 6. 扩展性设计

### 6.1 新增协议的扩展点

```
扩展一个新协议（以 MQTT 为例）需要：

1. 实现层 ─── protocols/mqtt/MqttClient.java
                 implements ProtocolClient

2. SPI 注册 ── META-INF/services/com.framework.core.client.ProtocolClient
                 添加一行：com.framework.protocols.mqtt.MqttClient

3. 步骤定义 ── stepdefs/mqtt/MqttStepDefs.java
                 使用 @Given/@When/@Then 定义 MQTT 特有步骤

4. 测试用例 ── features/mqtt/*.feature
                 @mqtt 标签的 Gherkin 场景

5. 配置项 ──── config/application.yml
                 添加 mqtt.broker-url 等配置
```

### 6.2 扩展矩阵

| 扩展需求                    | 改动范围                   | 是否影响现有代码      |
| --------------------------- | -------------------------- | --------------------- |
| 新增协议 (SOAP/MQTT/gRPC)   | 新增实现类 + SPI 注册      | ❌ 不影响             |
| 新增中间件 (Kafka/RabbitMQ) | 新增实现类 + SPI 注册      | ❌ 不影响             |
| 新增环境                    | 新增 application-{env}.yml | ❌ 不影响             |
| 新增步骤定义                | 新增 StepDefs 类           | ❌ 不影响             |
| 新增 Maven Profile          | 修改 pom.xml profiles      | ❌ 不影响核心代码     |
| 修改核心接口                | 所有实现类需适配           | ⚠️ 有影响（谨慎操作） |
