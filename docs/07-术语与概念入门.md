# 术语与概念入门

> 版本：1.0.0 | 最后更新：2026-02-28
>
> 本文档面向初学者，解释本框架涉及的缩写、关键概念和核心技术。

---

## 1. 缩写速查表

| 缩写    | 英文全称                                        | 中文含义                | 简要说明                                   |
| ------- | ----------------------------------------------- | ----------------------- | ------------------------------------------ |
| API     | Application Programming Interface               | 应用程序编程接口        | 软件之间通信的约定和规则                   |
| REST    | Representational State Transfer                 | 表述性状态转移          | 一种 Web API 的设计风格                    |
| HTTP    | HyperText Transfer Protocol                     | 超文本传输协议          | 浏览器与服务器之间通信的协议               |
| HTTPS   | HTTP Secure                                     | 安全超文本传输协议      | HTTP 的加密版本（通过 SSL/TLS）            |
| JSON    | JavaScript Object Notation                      | JavaScript 对象表示法   | 轻量级数据交换格式                         |
| XML     | Extensible Markup Language                      | 可扩展标记语言          | 标签式数据格式，常用于 SOAP                |
| YAML    | YAML Ain't Markup Language                      | —                       | 人类友好的配置文件格式                     |
| SOAP    | Simple Object Access Protocol                   | 简单对象访问协议        | 基于 XML 的 Web 服务协议                   |
| MQTT    | Message Queuing Telemetry Transport             | 消息队列遥测传输        | 轻量级物联网消息协议                       |
| BDD     | Behavior-Driven Development                     | 行为驱动开发            | 用自然语言描述测试的开发方法               |
| TDD     | Test-Driven Development                         | 测试驱动开发            | 先写测试再写代码的开发方法                 |
| SPI     | Service Provider Interface                      | 服务提供者接口          | Java 的插件发现与加载机制                  |
| DI      | Dependency Injection                            | 依赖注入                | 由外部提供对象依赖，而非自己创建           |
| DTO     | Data Transfer Object                            | 数据传输对象            | 用于在层之间传递数据的简单对象             |
| CRUD    | Create, Read, Update, Delete                    | 增、查、改、删          | 数据操作的四种基本方式                     |
| CI/CD   | Continuous Integration / Continuous Delivery    | 持续集成 / 持续交付     | 自动化构建、测试和部署流程                 |
| JDK     | Java Development Kit                            | Java 开发工具包         | 编写和运行 Java 程序所需的工具集           |
| JVM     | Java Virtual Machine                            | Java 虚拟机             | 运行 Java 字节码的虚拟机                   |
| JAR     | Java Archive                                    | Java 归档文件           | Java 程序的打包格式（`.jar` 文件）         |
| POM     | Project Object Model                            | 项目对象模型            | Maven 的项目配置文件（`pom.xml`）          |
| URL     | Uniform Resource Locator                        | 统一资源定位符          | 网络资源的地址（如 `https://example.com`） |
| URI     | Uniform Resource Identifier                     | 统一资源标识符          | 标识资源的字符串，URL 是其子集             |
| SSL/TLS | Secure Sockets Layer / Transport Layer Security | 安全套接层 / 传输层安全 | 网络通信加密协议                           |
| PAT     | Personal Access Token                           | 个人访问令牌            | GitHub 等平台的身份验证凭据                |
| SSH     | Secure Shell                                    | 安全外壳协议            | 安全远程连接与文件传输协议                 |
| UTF-8   | 8-bit Unicode Transformation Format             | —                       | 通用字符编码格式，支持中文等多语言         |

---

## 2. 核心概念详解

### 2.1 REST API — 理解 Web 接口

**什么是 API？**

想象 API 就像餐厅的菜单 —— 你（客户端）根据菜单（API 文档）点菜（发送请求），厨房（服务器）做好菜后端给你（返回响应）。你不需要知道菜是怎么做的，只需要知道怎么点菜。

**什么是 REST？**

REST 是一种设计 API 的风格，它使用标准的 HTTP 方法操作资源：

| HTTP 方法 | 操作      | 类比             | 示例                                 |
| --------- | --------- | ---------------- | ------------------------------------ |
| `GET`     | 查询/读取 | 查看菜单         | `GET /users/1` → 查询 ID 为 1 的用户 |
| `POST`    | 创建      | 提交新订单       | `POST /users` → 创建新用户           |
| `PUT`     | 全量更新  | 重新下单         | `PUT /users/1` → 完全替换用户信息    |
| `PATCH`   | 部分更新  | 修改订单中的一项 | `PATCH /users/1` → 修改部分字段      |
| `DELETE`  | 删除      | 取消订单         | `DELETE /users/1` → 删除用户         |

**HTTP 状态码：**

| 范围  | 含义       | 常见码                                                 |
| ----- | ---------- | ------------------------------------------------------ |
| `2xx` | 成功       | `200` 成功、`201` 已创建、`204` 无内容                 |
| `3xx` | 重定向     | `301` 永久移动、`302` 临时重定向                       |
| `4xx` | 客户端错误 | `400` 请求错误、`401` 未授权、`403` 禁止、`404` 未找到 |
| `5xx` | 服务器错误 | `500` 内部错误、`502` 网关错误、`503` 服务不可用       |

---

### 2.2 JSON — 数据交换格式

JSON 是 API 中最常用的数据格式，结构简单直观：

```json
{
  "name": "张三",
  "age": 30,
  "isActive": true,
  "skills": ["Java", "Python", "测试"],
  "address": {
    "city": "上海",
    "zipCode": "200000"
  }
}
```

**基本类型：**

- **字符串**：`"hello"` — 用双引号包裹
- **数字**：`42`、`3.14` — 不需要引号
- **布尔值**：`true` 或 `false`
- **空值**：`null`
- **数组**：`[1, 2, 3]` — 有序列表
- **对象**：`{"key": "value"}` — 键值对集合

---

### 2.3 JSON Path — 从 JSON 中提取数据

JSON Path 类似于文件路径，用来定位 JSON 中的特定数据。

假设有以下 JSON：

```json
{
  "store": {
    "name": "书店",
    "books": [
      { "title": "Java 入门", "price": 49.9 },
      { "title": "Python 实战", "price": 59.9 }
    ]
  }
}
```

| JSON Path 表达式         | 结果                           | 说明                   |
| ------------------------ | ------------------------------ | ---------------------- |
| `$.store.name`           | `"书店"`                       | 访问嵌套字段           |
| `$.store.books[0].title` | `"Java 入门"`                  | 数组第一个元素的 title |
| `$.store.books[1].price` | `59.9`                         | 数组第二个元素的 price |
| `$.store.books[*].title` | `["Java 入门", "Python 实战"]` | 所有元素的 title       |
| `$..title`               | `["Java 入门", "Python 实战"]` | 递归搜索所有 title     |

> 在本框架中，JSON Path 断言用于验证 API 响应内容：
>
> ```gherkin
> Then the JSON path "$.store.name" should equal "书店"
> ```

---

### 2.4 BDD 与 Cucumber — 用自然语言写测试

**什么是 BDD？**

BDD（行为驱动开发）的核心思想是：**用所有人都能理解的语言描述软件行为**。不需要懂编程，也能理解测试内容。

**什么是 Cucumber？**

Cucumber 是实现 BDD 的工具。它读取用 **Gherkin** 语法编写的 `.feature` 文件，并执行对应的 Java 代码。

**Gherkin 关键字：**

| 关键字             | 含义      | 用途                       |
| ------------------ | --------- | -------------------------- |
| `Feature`          | 功能      | 描述测试的功能模块         |
| `Scenario`         | 场景      | 一个具体的测试用例         |
| `Given`            | 假设/前提 | 设置初始条件               |
| `When`             | 当/操作   | 执行某个动作               |
| `Then`             | 那么/验证 | 检查预期结果               |
| `And`              | 并且      | 连接同类型步骤             |
| `But`              | 但是      | 连接同类型步骤（用于否定） |
| `Background`       | 背景      | 所有场景共享的前置步骤     |
| `Scenario Outline` | 场景大纲  | 数据驱动的参数化测试       |
| `Examples`         | 示例      | 为场景大纲提供测试数据     |

**完整示例：**

```gherkin
Feature: 用户登录
  作为网站用户
  我需要通过用户名和密码登录
  以访问我的个人页面

  Scenario: 正确的用户名和密码
    Given 用户访问登录页面              # ← 前提条件
    When 用户输入用户名 "admin"         # ← 执行操作
    And 用户输入密码 "123456"
    And 用户点击登录按钮
    Then 页面应显示 "欢迎回来"           # ← 验证结果

  Scenario: 错误的密码
    Given 用户访问登录页面
    When 用户输入用户名 "admin"
    And 用户输入密码 "wrong"
    And 用户点击登录按钮
    Then 页面应显示 "密码错误"
```

---

### 2.5 Maven — 项目构建工具

**什么是 Maven？**

Maven 是 Java 项目的"管家"，负责：

- **依赖管理**：自动下载项目需要的第三方库（如 REST Assured、Cucumber）
- **项目构建**：编译代码、运行测试、打包发布
- **标准目录结构**：统一项目布局

**项目结构：**

```
项目根目录/
├── pom.xml                          ← Maven 配置文件（最重要！）
├── src/main/java/                   ← 主代码
├── src/main/resources/              ← 主资源文件
├── src/test/java/                   ← 测试代码
├── src/test/resources/              ← 测试资源文件
└── target/                          ← 构建输出（自动生成）
```

**pom.xml 核心元素：**

```xml
<project>
  <groupId>com.framework</groupId>      <!-- 组织/公司 ID -->
  <artifactId>api-test-framework</artifactId>  <!-- 项目名 -->
  <version>1.0.0-SNAPSHOT</version>      <!-- 版本号 -->

  <dependencies>                         <!-- 依赖列表 -->
    <dependency>
      <groupId>io.rest-assured</groupId> <!-- 依赖的组织 -->
      <artifactId>rest-assured</artifactId> <!-- 依赖的名称 -->
      <version>5.5.0</version>           <!-- 依赖的版本 -->
    </dependency>
  </dependencies>
</project>
```

**常用命令解读：**
| 命令 | 做什么 |
|------|--------|
| `mvnw clean` | 清除上次构建的输出 (`target/` 目录) |
| `mvnw compile` | 编译 Java 源代码 |
| `mvnw test` | 编译代码并运行测试 |
| `mvnw package` | 编译 + 测试 + 打包为 JAR |
| `mvnw clean test` | 先清理，再编译和测试（推荐） |

**什么是 Maven Wrapper？**

Maven Wrapper（`mvnw` / `mvnw.cmd`）是 Maven 的"便携版"。它让项目自带 Maven，无需在系统上全局安装。团队成员克隆项目后直接运行 `.\mvnw.cmd test` 即可，确保每个人使用相同版本的 Maven。

---

### 2.6 JUnit 5 — 测试引擎

**什么是 JUnit？**

JUnit 是 Java 最主流的测试框架。JUnit 5 是最新版本，由三个模块组成：

```
JUnit 5
├── JUnit Platform  ← 测试运行平台（发现和执行测试的基础设施）
├── JUnit Jupiter   ← JUnit 自己的测试 API（@Test 等注解）
└── JUnit Vintage   ← 兼容旧版 JUnit 3/4
```

在本框架中，JUnit 5 **Platform** 作为测试运行平台，Cucumber 作为测试引擎插入其中。

---

### 2.7 REST Assured — HTTP 客户端库

**什么是 REST Assured？**

REST Assured 是专为测试 REST API 设计的 Java 库，语法直观可读：

```java
// 发送 GET 请求并验证响应
given()
    .baseUri("https://api.example.com")
    .header("Authorization", "Bearer token123")
.when()
    .get("/users/1")
.then()
    .statusCode(200)
    .body("name", equalTo("张三"));
```

> 在本框架中，REST Assured 被封装在 `RestClient` 类中，使用者通过 Gherkin 步骤调用，无需直接编写 Java 代码。

---

### 2.8 SPI — 插件发现机制

**什么是 SPI？**

SPI（Service Provider Interface）是 Java 内置的插件发现机制。它允许框架在运行时自动找到并加载实现类，无需硬编码。

**类比理解：**

就像 USB 接口 —— 只要设备符合 USB 标准（接口），插上就能用（SPI 发现），不管是鼠标、键盘还是U盘（不同实现）。

**在本项目中 SPI 是怎么工作的？一步步来看：**

#### 第一步：定义接口（"USB 标准"）

`ProtocolClient.java` 定义了所有协议客户端必须遵守的规范：

```java
// src/main/java/com/framework/core/client/ProtocolClient.java
public interface ProtocolClient {
    void init(ConfigManager config);            // 初始化客户端
    ProtocolResponse execute(ProtocolRequest request);  // 执行请求
    String getProtocolName();                   // 返回协议名（如 "REST"）
    default void close() { }                    // 清理资源
}
```

> 这个接口就是"标准" —— 不管是 REST、SOAP 还是 MQTT，都必须实现这 4 个方法。

#### 第二步：编写实现（"符合标准的设备"）

`RestClient.java` 是目前唯一的实现，用 REST Assured 库发送 HTTP 请求：

```java
// src/main/java/com/framework/protocols/rest/RestClient.java
public class RestClient implements ProtocolClient {

    @Override
    public String getProtocolName() {
        return "REST";  // 告诉框架：我负责处理 REST 协议
    }

    @Override
    public void init(ConfigManager config) {
        // 从配置文件读取 base-url、超时时间等，初始化 REST Assured
        this.baseUrl = config.getString("rest.base-url", "http://localhost:8080");
        RestAssured.baseURI = this.baseUrl;
        // ...更多初始化代码
    }

    @Override
    public ProtocolResponse execute(ProtocolRequest request) {
        // 把通用的 ProtocolRequest 翻译成 REST Assured 请求，发送并返回结果
        // ...具体实现代码
    }
}
```

#### 第三步：注册实现（"告诉系统有这个设备"）

在 `META-INF/services/` 目录下创建一个文件：

```
文件路径：src/main/resources/META-INF/services/com.framework.core.client.ProtocolClient
文件内容：com.framework.protocols.rest.RestClient
```

> **文件名** = 接口的完整类名
> **文件内容** = 实现类的完整类名（每行一个，将来新增 SOAP 只需加一行）

#### 第四步：框架自动发现（"即插即用"）

`ProtocolClientFactory` 在启动时自动扫描所有注册的实现：

```java
// src/main/java/com/framework/core/client/ProtocolClientFactory.java
private void discoverClients() {
    // Java 内置的 ServiceLoader 会扫描 META-INF/services/ 目录
    ServiceLoader<ProtocolClient> loader = ServiceLoader.load(ProtocolClient.class);
    for (ProtocolClient client : loader) {
        // 自动发现并注册，例如："REST" → RestClient.class
        registry.put(client.getProtocolName().toUpperCase(), client.getClass());
        log.info("Auto-discovered protocol client: {} -> {}",
                client.getProtocolName(), client.getClass().getSimpleName());
    }
}
```

**完整调用链图解：**

```
框架启动
  │
  ▼
ProtocolClientFactory 构造函数
  │
  ├── discoverClients()
  │     │
  │     ▼
  │   ServiceLoader 扫描 META-INF/services/ 文件
  │     │
  │     ▼
  │   发现 RestClient → 注册到 registry {"REST": RestClient.class}
  │   (将来 SoapClient → 注册 {"SOAP": SoapClient.class})
  │
  ▼
测试执行时调用 getClient("REST")
  │
  ▼
从 registry 找到 RestClient.class → 创建实例 → 调用 init() → 缓存并返回
```

**将来添加 SOAP 支持时，只需要：**
1. 编写 `SoapClient implements ProtocolClient`
2. 在 SPI 文件中加一行 `com.framework.protocols.soap.SoapClient`
3. 框架自动发现 —— **不需要修改任何现有代码！**

---

### 2.9 依赖注入（DI）

**什么是依赖注入？**

假设 A 需要使用 B：

**不用 DI（自己创建）：**

```java
class A {
    private B b = new B();  // A 自己创建 B，A 和 B 紧密耦合
}
```

**使用 DI（外部提供）：**

```java
class A {
    private B b;
    A(B b) { this.b = b; }  // B 从外部传入，A 不关心 B 怎么创建
}
```

**好处**：更灵活、更容易测试、更容易替换实现。

#### DI 在本项目中如何工作？

本框架使用 **PicoContainer** 作为 DI 容器（它是 Cucumber 内置的依赖注入工具）。下面详细讲解它如何在本项目中运作。

**核心问题：多个类如何共享数据？**

在测试执行过程中，有多个类需要协同工作：
- `Hooks.java` — 场景开始前/结束后的操作
- `RestStepDefs.java` — 解释执行 Gherkin 步骤的逻辑

它们都需要访问同一个 `TestContext`（测试上下文）来共享请求和响应数据。

**PicoContainer 的解决方案：构造器注入**

看看本项目的实际代码：

```java
// src/test/java/com/framework/hooks/Hooks.java
public class Hooks {
    private final TestContext context;  // 需要 TestContext

    // PicoContainer 看到构造器需要 TestContext，就自动创建一个并传入
    public Hooks(TestContext context) {
        this.context = context;
    }

    @Before
    public void beforeScenario(Scenario scenario) {
        log.info("========== SCENARIO START: {} ==========", scenario.getName());
    }

    @After
    public void afterScenario(Scenario scenario) {
        // 可以访问 context.getLastResponse() 获取响应数据
        if (scenario.isFailed() && context.getLastResponse() != null) {
            scenario.attach(context.getLastResponse().getBody(), "text/plain", "Last Response Body");
        }
        context.cleanup();  // 清理数据
    }
}
```

```java
// src/test/java/com/framework/stepdefs/rest/RestStepDefs.java
public class RestStepDefs {
    private final TestContext context;  // 也需要 TestContext

    // PicoContainer 注入的是 **同一个** TestContext 实例！
    public RestStepDefs(TestContext context) {
        this.context = context;
    }

    @Given("the REST API base URL is {string}")
    public void setBaseUrl(String baseUrl) {
        context.set("rest.base-url.override", baseUrl);  // 写入共享数据
    }

    @When("I send a GET request to {string}")
    public void sendGet(String endpoint) {
        // 构建请求、执行、存储响应到 context
        context.setLastResponse(response);  // 同一个 context 对象
    }

    @Then("the response status code should be {int}")
    public void verifyStatusCode(int expected) {
        // 从共享的 context 中获取响应来断言
        assertThat(context.getLastResponse().getStatusCode()).isEqualTo(expected);
    }
}
```

**关键点：构造器参数类型相同 = 同一个实例**

```
场景执行开始
  │
  ▼
PicoContainer 看到 Hooks 和 RestStepDefs 都需要 TestContext
  │
  ├── 第一次遇到 TestContext → 创建新实例 (new TestContext())
  │
  ├── Hooks(context)        ← 传入这个实例
  │
  └── RestStepDefs(context) ← 传入同一个实例！
  │
  ▼
所以 Hooks 和 RestStepDefs 操作的是同一份数据
```

**每个 Scenario 都会重新创建：**

```
Scenario 1: 查询用户
  ├── PicoContainer 创建 TestContext #1
  ├── Hooks 使用 TestContext #1
  ├── RestStepDefs 使用 TestContext #1
  └── 场景结束 → TestContext #1 被丢弃

Scenario 2: 创建帖子
  ├── PicoContainer 创建 TestContext #2  ← 全新的！
  ├── Hooks 使用 TestContext #2
  ├── RestStepDefs 使用 TestContext #2
  └── 场景结束 → TestContext #2 被丢弃
```

> **这就是"场景隔离"** —— Scenario 1 中设置的 Header、Body 等数据不会泄漏到 Scenario 2。

**如果没有 DI 会怎样？（反面示例）**

```java
// ❌ 错误做法：使用静态变量共享
public class RestStepDefs {
    static TestContext context = new TestContext();  // 所有场景共用！
}

// 问题：
// 1. Scenario 1 设置了 Header "Authorization"，Scenario 2 也会带上（数据污染）
// 2. 并行执行时多个线程同时修改，数据混乱（线程不安全）
// 3. 测试结果不稳定，时好时坏，排查困难
```

**总结 DI 在本项目中的作用：**

| 特性 | 说明 |
|------|------|
| 自动创建 | 不需要手动 `new TestContext()`，PicoContainer 自动创建 |
| 共享实例 | 同一场景中，所有类拿到的是同一个 TestContext |
| 场景隔离 | 每个场景有自己独立的 TestContext，互不干扰 |
| 自动清理 | 场景结束后 PicoContainer 自动销毁 TestContext |
| 简洁代码 | 只需要在构造器中声明参数，无需管理生命周期 |

---

### 2.10 YAML — 配置文件格式

**什么是 YAML？**

YAML 是一种简洁的配置文件格式，比 JSON 和 XML 更易读：

```yaml
# 这是注释
rest:
  base-url: https://api.example.com # 字符串
  connect-timeout: 5000 # 数字
  log-requests: true # 布尔值

# 列表
environments:
  - dev
  - staging
  - prod
```

**与 JSON 对比：**

| 特性   | YAML           | JSON             |
| ------ | -------------- | ---------------- |
| 注释   | ✅ 支持（`#`） | ❌ 不支持        |
| 引号   | 通常不需要     | 字符串必须双引号 |
| 可读性 | ⭐⭐⭐ 非常好  | ⭐⭐ 还行        |
| 对齐   | 用缩进表示层级 | 用 `{}` 和 `[]`  |
| 用途   | 配置文件       | 数据传输         |

---

### 2.11 TestContext — 测试上下文（场景数据中枢）

**什么是 TestContext？**

`TestContext` 是本框架中最重要的共享对象。它就像一个"工作台"，一个 Scenario 执行过程中所有数据都放在这张桌子上。

```java
// src/main/java/com/framework/core/context/TestContext.java
public class TestContext {
    private final ConfigManager config;            // 配置管理器
    private final ProtocolClientFactory clientFactory;  // 协议客户端工厂
    private ProtocolRequest currentRequest;        // 当前正在构建的请求
    private ProtocolResponse lastResponse;         // 最后一次收到的响应
    private final Map<String, Object> scenarioData;    // 场景共享数据

    public TestContext() {
        this.config = new ConfigManager();          // 自动加载 YAML 配置
        this.clientFactory = new ProtocolClientFactory(config);  // 自动发现协议客户端
    }
}
```

**数据流转过程图解：**

```gherkin
Given the REST API base URL is "https://jsonplaceholder.typicode.com"
  → 数据写入 TestContext.scenarioData

Given I set header "Content-Type" to "application/json"
  → 数据写入 TestContext.currentRequest.headers

When I send a POST request to "/users" with body: ...
  → 从 TestContext.currentRequest 取出所有数据
  → 通过 TestContext.clientFactory 获取 RestClient
  → RestClient 执行 HTTP 请求
  → 响应写入 TestContext.lastResponse

Then the response status code should be 201
  → 从 TestContext.lastResponse 读取状态码
  → 做断言比较

Then I store the JSON path "$.id" as "newUserId"
  → 从 TestContext.lastResponse 提取数据
  → 存入 TestContext.scenarioData["newUserId"]
```

> TestContext 就是把请求构建、请求执行、响应验证串联起来的"数据中枢"。

---

### 2.12 工厂模式 — ProtocolClientFactory

**什么是工厂模式？**

工厂模式是一种设计模式：你不直接 `new` 一个对象，而是找"工厂"要。工厂决定创建什么类型的对象。

**在本项目中的实际代码：**

```java
// 不用工厂（硬编码，不灵活）：
ProtocolClient client = new RestClient();  // 写死了 REST

// 使用工厂（灵活，可扩展）：
ProtocolClient client = clientFactory.getClient("REST");   // 要 REST 客户端
ProtocolClient client = clientFactory.getClient("SOAP");   // 要 SOAP 客户端
ProtocolClient client = clientFactory.getClient("MQTT");   // 要 MQTT 客户端
```

`ProtocolClientFactory` 内部维护着一个注册表和实例缓存：

```java
public class ProtocolClientFactory {
    // 注册表：协议名 → 类（由 SPI 自动填充）
    // { "REST": RestClient.class, "SOAP": SoapClient.class, ... }
    private final Map<String, Class<? extends ProtocolClient>> registry;

    // 实例缓存：协议名 → 已初始化的实例（避免重复创建）
    // { "REST": <已初始化的 RestClient 对象> }
    private final Map<String, ProtocolClient> instances;

    public ProtocolClient getClient(String protocolName) {
        // 1. 如果缓存中已有，直接返回（不重复创建）
        // 2. 如果没有，从 registry 找到对应的类
        // 3. 创建实例 → 调用 init() 初始化 → 放入缓存 → 返回
    }
}
```

**SPI + 工厂模式的协作关系：**

```
SPI（发现机制）  ──→  工厂（创建管理）  ──→  客户端（执行请求）

启动时：                使用时：                运行时：
ServiceLoader          getClient("REST")      client.execute(request)
扫描 META-INF/         查注册表 → 创建实例      发送 HTTP 请求
填充 registry          → 初始化 → 缓存          → 返回响应
```

---

## 3. 本框架技术栈一览

```
┌──────────────────────────────────────────────────┐
│                  测试框架技术栈                     │
├──────────────┬───────────────────────────────────┤
│ 编程语言      │ Java 21 LTS                       │
│ 构建工具      │ Maven 3.9（通过 Wrapper）           │
│ BDD 框架     │ Cucumber 7.20（Gherkin 语法）       │
│ 测试引擎      │ JUnit 5 Platform                  │
│ HTTP 客户端   │ REST Assured 5.5                  │
│ JSON 处理    │ Jackson 2.18 + JsonPath 2.9       │
│ 断言库        │ AssertJ 3.27                      │
│ 依赖注入      │ PicoContainer（Cucumber 内置）      │
│ 日志          │ SLF4J 2.0 + Logback 1.5          │
│ 配置管理      │ SnakeYAML 2.3                     │
│ 代码简化      │ Lombok 1.18                       │
│ 插件机制      │ Java SPI                          │
├──────────────┼───────────────────────────────────┤
│ 未来扩展      │ SOAP / MQTT / Kafka               │
└──────────────┴───────────────────────────────────┘
```

---

## 4. 框架运行流程图解

```
你编写的 Feature 文件（Gherkin 语法）
        │
        ▼
  ┌─────────────┐
  │  Cucumber    │  读取 .feature 文件，匹配步骤定义
  │  (BDD 框架)  │
  └──────┬──────┘
         │
         ▼
  ┌─────────────┐
  │ Step Defs    │  每个 Gherkin 步骤对应一个 Java 方法
  │ (步骤定义)    │
  └──────┬──────┘
         │ 使用
         ▼
  ┌─────────────┐
  │ TestContext   │  存储请求/响应数据、共享变量
  │ (测试上下文)   │  每个 Scenario 独立一份
  └──────┬──────┘
         │ 调用
         ▼
  ┌─────────────┐
  │ Protocol     │  SPI 自动发现（RestClient / SoapClient / ...）
  │ Client       │
  │ (协议客户端)   │
  └──────┬──────┘
         │ 通过 HTTP / SOAP / MQTT / Kafka
         ▼
  ┌─────────────┐
  │ 被测 API     │  你的应用服务器
  │ Server       │
  └─────────────┘
```

---

## 5. 进一步学习资源

| 主题          | 推荐资源             | 链接                                              |
| ------------- | -------------------- | ------------------------------------------------- |
| REST API 入门 | RESTful API 设计指南 | https://restfulapi.net/                           |
| JSON          | JSON 官方介绍        | https://www.json.org/json-zh.html                 |
| JSON Path     | 在线测试工具         | https://jsonpath.com/                             |
| Cucumber      | 官方文档             | https://cucumber.io/docs/                         |
| Gherkin       | 语法参考             | https://cucumber.io/docs/gherkin/reference/       |
| REST Assured  | 官方指南             | https://rest-assured.io/                          |
| Maven         | 入门教程             | https://maven.apache.org/guides/getting-started/  |
| JUnit 5       | 用户手册             | https://junit.org/junit5/docs/current/user-guide/ |
| Java 21       | 新特性概览           | https://openjdk.org/projects/jdk/21/              |
| YAML          | 语法速查             | https://yaml.org/                                 |
