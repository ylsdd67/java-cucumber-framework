# 实现详解文档

> 版本：1.0.0 | 最后更新：2026-02-28

---

## 1. 核心层实现

### 1.1 ProtocolClient.java — 协议客户端接口

**文件位置：** `src/main/java/com/framework/core/client/ProtocolClient.java`

```java
public interface ProtocolClient {
    void init(ConfigManager config);
    ProtocolResponse execute(ProtocolRequest request);
    String getProtocolName();
    default void close() {}
}
```

**设计说明：**

| 方法                | 职责                      | 调用时机                 |
| ------------------- | ------------------------- | ------------------------ |
| `init(config)`      | 读取配置、初始化连接      | 客户端首次被工厂创建时   |
| `execute(request)`  | 执行协议请求并返回响应    | 每次步骤定义调用时       |
| `getProtocolName()` | 返回协议标识（如 "REST"） | 工厂注册和日志时         |
| `close()`           | 释放连接等资源            | 场景结束或测试套件结束时 |

- 使用 `default` 关键字让 `close()` 成为可选实现
- `init()` 接收 `ConfigManager` 而非具体配置值，保持灵活性

---

### 1.2 ProtocolRequest.java — 通用请求模型

**文件位置：** `src/main/java/com/framework/core/client/ProtocolRequest.java`

**请求模型采用 Fluent Builder 风格：**

```java
// 示例：构建一个 REST 请求
ProtocolRequest request = new ProtocolRequest()
    .method("POST")
    .endpoint("/api/users")
    .contentType("application/json")
    .header("Authorization", "Bearer token123")
    .body("{\"name\": \"张三\"}")
    .queryParam("page", "1");
```

**字段设计考量：**

| 字段       | REST 用途               | MQTT 用途         | Kafka 用途      |
| ---------- | ----------------------- | ----------------- | --------------- |
| `endpoint` | URL 路径                | Topic 名称        | Topic 名称      |
| `method`   | HTTP 方法 (GET/POST...) | PUBLISH/SUBSCRIBE | PRODUCE/CONSUME |
| `headers`  | HTTP 请求头             | MQTT 属性         | Kafka Headers   |
| `body`     | 请求体 (JSON/XML)       | 消息负载          | 消息值          |
| `extras`   | 原始响应对象            | QoS、Retain       | Partition、Key  |

---

### 1.3 ProtocolResponse.java — 通用响应模型

**文件位置：** `src/main/java/com/framework/core/client/ProtocolResponse.java`

同样使用 Fluent Builder，提供**大小写不敏感**的 Header 查询：

```java
// getHeader() 支持大小写不敏感查找
String contentType = response.getHeader("Content-Type");
String contentType = response.getHeader("content-type"); // 同样有效
```

`headers` 返回 `Collections.unmodifiableMap()`，确保响应数据**不可变**。

---

### 1.4 ProtocolClientFactory.java — 协议客户端工厂

**文件位置：** `src/main/java/com/framework/core/client/ProtocolClientFactory.java`

**工厂的核心流程：**

```
构造函数调用
    │
    ↓
discoverClients() ─── ServiceLoader 扫描 SPI 文件
    │                  META-INF/services/com.framework.core.client.ProtocolClient
    ↓
registry 填充 ─── { "REST" → RestClient.class, ... }
    │
    ↓
getClient("REST") 被调用时
    │
    ↓
instances.computeIfAbsent() ─── 懒加载
    │
    ├── newInstance() 反射创建实例
    ├── client.init(config) 初始化
    └── 缓存到 instances Map
```

**关键实现细节：**

1. **线程安全**：使用 `ConcurrentHashMap` 存储 registry 和 instances
2. **懒加载**：客户端在首次 `getClient()` 时创建，不是启动时全部创建
3. **缓存复用**：同一协议的客户端在整个场景中只创建一次
4. **双重注册**：支持 SPI 自动发现 + `register()` 手动注册

---

### 1.5 ConfigManager.java — 配置管理器

**文件位置：** `src/main/java/com/framework/core/config/ConfigManager.java`

**配置加载流程：**

```
new ConfigManager()
    │
    ├── 读取环境标识: System.getProperty("env") || ENV 环境变量 || 默认 "dev"
    │
    ├── 加载 config/application.yml (基础配置)
    │   └── 递归扁平化: {rest: {base-url: "..."}} → {"rest.base-url": "..."}
    │
    ├── 加载 config/application-{env}.yml (环境覆盖)
    │   └── 同名 key 覆盖基础配置
    │
    └── 合并为不可变 Map
```

**属性解析优先级（resolve 方法）：**

```java
private String resolve(String key) {
    // 1. 系统属性 (最高优先级)
    String sys = System.getProperty(key);         // -Drest.base-url=...
    if (sys != null) return sys;

    // 2. 环境变量 (自动转换格式)
    String envKey = key.toUpperCase()              // rest.base-url
            .replace('.', '_')                     // → REST_BASE_URL
            .replace('-', '_');
    String env = System.getenv(envKey);
    if (env != null) return env;

    // 3. YAML 配置 (最低优先级)
    Object val = properties.get(key);
    return val != null ? val.toString() : null;
}
```

---

### 1.6 TestContext.java — 测试上下文

**文件位置：** `src/main/java/com/framework/core/context/TestContext.java`

**场景级别的依赖注入：**

Cucumber 使用 PicoContainer 作为 DI 容器。每个 Scenario 开始时：

1. PicoContainer 创建一个新的 `TestContext` 实例
2. 所有 Step Definition 类的构造函数接收同一个 `TestContext`
3. Scenario 结束后，`TestContext` 被丢弃

```java
// Hooks.java 和 RestStepDefs.java 共享同一个 TestContext 实例
public class Hooks {
    private final TestContext context;
    public Hooks(TestContext context) { this.context = context; }  // 注入
}

public class RestStepDefs {
    private final TestContext context;
    public RestStepDefs(TestContext context) { this.context = context; }  // 同实例
}
```

**数据传递机制：**

```java
// 步骤 A：存储数据
context.set("userId", 12345);

// 步骤 B：读取数据（支持泛型）
Integer userId = context.get("userId");
```

---

## 2. 协议实现层

### 2.1 RestClient.java — REST 协议实现

**文件位置：** `src/main/java/com/framework/protocols/rest/RestClient.java`

**REST Assured 请求构建流程：**

```
ProtocolRequest                          REST Assured
─────────────                            ─────────────
headers         ──────→                  spec.headers(...)
queryParams     ──────→                  spec.queryParams(...)
pathParams      ──────→                  spec.pathParams(...)
contentType     ──────→                  spec.contentType(...)
authToken       ──────→                  spec.header("Authorization", "Bearer ...")
basicAuth       ──────→                  spec.auth().preemptive().basic(user, pwd)
body            ──────→                  spec.body(...)
method+endpoint ──────→                  spec.get/post/put/delete(endpoint)
```

**HTTP 方法分发使用 Java 21 Switch 表达式：**

```java
Response response = switch (method) {
    case "GET"     -> spec.get(endpoint);
    case "POST"    -> spec.post(endpoint);
    case "PUT"     -> spec.put(endpoint);
    case "PATCH"   -> spec.patch(endpoint);
    case "DELETE"  -> spec.delete(endpoint);
    case "HEAD"    -> spec.head(endpoint);
    case "OPTIONS" -> spec.options(endpoint);
    default -> throw new IllegalArgumentException("Unsupported HTTP method: " + method);
};
```

**初始化配置映射：**

| YAML 配置项          | REST Assured 设置                         |
| -------------------- | ----------------------------------------- |
| `rest.base-url`      | `RestAssured.baseURI`                     |
| `rest.relaxed-https` | `RestAssured.useRelaxedHTTPSValidation()` |
| `rest.timeout-ms`    | `HttpClientConfig` 连接和读取超时         |

---

## 3. 测试层实现

### 3.1 CucumberRunner.java — 测试运行器

**文件位置：** `src/test/java/com/framework/runners/CucumberRunner.java`

```java
@Suite
@IncludeEngines("cucumber")
@SelectClasspathResource("features")
@ConfigurationParameter(key = GLUE_PROPERTY_NAME,
    value = "com.framework.stepdefs,com.framework.hooks")
```

**注解说明：**

| 注解                                   | 作用                             |
| -------------------------------------- | -------------------------------- |
| `@Suite`                               | JUnit 5 测试套件                 |
| `@IncludeEngines("cucumber")`          | 使用 Cucumber 引擎执行           |
| `@SelectClasspathResource("features")` | 扫描 `features/` 目录            |
| `@ConfigurationParameter`              | 配置 Cucumber 的 glue、plugin 等 |

`junit-platform.properties` 中的配置也会被 Cucumber 引擎读取。

### 3.2 Hooks.java — 生命周期钩子

**文件位置：** `src/test/java/com/framework/hooks/Hooks.java`

| 钩子      | 执行时机       | 职责                                     |
| --------- | -------------- | ---------------------------------------- |
| `@Before` | 每个场景开始前 | 日志记录场景名称和标签                   |
| `@After`  | 每个场景结束后 | 失败时附加响应体到报告；清理 TestContext |

### 3.3 RestStepDefs.java — REST 步骤定义

**文件位置：** `src/test/java/com/framework/stepdefs/rest/RestStepDefs.java`

**步骤定义分类：**

| 类别     | Cucumber 关键字 | 步骤数量 | 功能                                      |
| -------- | --------------- | -------- | ----------------------------------------- |
| 请求构建 | `@Given`        | 10 个    | 设置 URL、Header、参数、Body、认证        |
| 请求执行 | `@When`         | 2 个     | 发送 HTTP 请求                            |
| 响应断言 | `@Then`         | 14 个    | 状态码、Body、Header、JSON Path、响应时间 |

**JSON Path 断言示例：**

```java
@Then("the JSON path {string} should equal {string}")
public void jsonPathEquals(String path, String expected) {
    String body = context.getLastResponse().getBody();
    Object actual = JsonPath.read(body, path);
    assertThat(String.valueOf(actual))
            .as("JSON path '%s'", path)
            .isEqualTo(expected);
}
```

---

## 4. SPI 注册机制

### 4.1 当前注册文件

**文件位置：** `src/main/resources/META-INF/services/com.framework.core.client.ProtocolClient`

```
com.framework.protocols.rest.RestClient
```

### 4.2 扩展方式

新增协议时，只需在该文件追加一行全类名：

```
com.framework.protocols.rest.RestClient
com.framework.protocols.soap.SoapClient
com.framework.protocols.mqtt.MqttClient
com.framework.protocols.kafka.KafkaClient
```

框架启动时，`ServiceLoader` 会自动扫描并注册所有列出的实现类。

---

## 5. 配置文件实现

### 5.1 application.yml — 基础配置

```yaml
rest:
  base-url: https://jsonplaceholder.typicode.com
  relaxed-https: false
  timeout-ms: 30000
```

### 5.2 application-dev.yml — 开发环境覆盖

```yaml
rest:
  base-url: https://jsonplaceholder.typicode.com
  relaxed-https: true # 开发环境允许自签名证书
```

### 5.3 junit-platform.properties — Cucumber 引擎配置

```properties
cucumber.plugin=pretty,html:target/cucumber-reports/cucumber.html,json:target/cucumber-reports/cucumber.json
cucumber.glue=com.framework.stepdefs,com.framework.hooks
cucumber.features=src/test/resources/features
cucumber.publish.quiet=true
```

### 5.4 logback-test.xml — 日志配置

- 控制台输出：简洁格式 `HH:mm:ss.SSS [thread] LEVEL logger - message`
- 文件输出：`target/logs/test-framework.log`，按日期+大小滚动
- 框架日志 (`com.framework`)：DEBUG 级别
- 第三方日志 (`io.restassured`, `org.apache.http`)：WARN 级别（减少噪音）
